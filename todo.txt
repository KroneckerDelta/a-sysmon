todo
----
* kurios
  * UUID.randomUUID() --> performance, blocking behavior

* architecture
  * resend data after failure --> just add to the queue again --> idempotence on the server

* server features
  * API for data retrieval
    * scalars, environment, traces
    * local and remote
  * simple web UI
    *
  * derived scalars as listeners on the event bus, e.g. 'requests per second', 'transactions per second' or 'GC frequency'
  * permission checks
    * collection with users / MD5 of password
    * admin flag, arrays of applications with read / write permissions
    * ?!?!?! --> Felix

* core
  * export? printer friendly presentation?

* presentation of active / open connections per pool: special treatment <active> / <open>

* load average from sun.misc.Unsafe --> Windows?!

* global measurements
  * /proc/diskstats

          Field 1 -- # of reads issued
          Field 2 -- # of reads merged, field 6 -- # of writes merged
          Field 3 -- # of sectors read
          Field 4 -- # of milliseconds spent reading
          Field 5 -- # of writes completed
          Field 7 -- # of sectors written
          Field 8 -- # of milliseconds spent writing
          Field 9 -- # of I/Os currently in progress
          Field 10 -- # of milliseconds spent doing I/Os
          Field 11 -- weighted # of milliseconds spent doing I/Os

          --> read aggregated values, calc 'current' values

  * /proc/stat

        These numbers identify the amount of time the CPU has spent performing different kinds of work. Time units are in USER_HZ or Jiffies (typically hundredths of a second).
         fields from left to right:

          user: normal processes executing in user mode
          nice: niced processes executing in user mode
          system: processes executing in kernel mode
          idle: twiddling thumbs
          iowait: waiting for I/O to complete
          irq: servicing interrupts
          softirq: servicing softirqs

          --> read aggregated values, calc 'current' values

  * /proc/net/dev

  * --> see code in 'meltdown'

  * how to differentiate between 'own' and 'foreign' load?!



* logo in report servlets (?)

* offloading data sink
  * unique ids per measurement --> referencing (?)
  * support for 'correcting' real time clocks of systems
  * per hierarchy: Thread name, Host, PID
* 'push' (via UDP) vs. 'pull' (store locally, collect e.g. via servlet call --> provide servlet)

* trace GC (?)
* log asysmon overhead (?)

* extract a-base
  * partial order
  * mapWithDefault, mapWithDefaultValue


AOP:
--> File I/O
--> Socket I/O


discuss
-------
* how to deal with data sources in app server --> outside application scope

documentation
-------------
* "globally disabled" by system property

* terminology
  * measurement: something ongoing --> something like a builder
  * data: immutable results of a finished measurement

* initialization
  * completely non-static
  * or static 'ASysMon.get()' --> AStaticSysMonConfig.get(), changes must be registered there before first access

* AMinMaxAvgServlet
  * load-on-startup = 1
  * security --> filter --> responsibility of the application
  * display
    * color coding / percentage: relative to immediate parent
    * #: average number of calls *per parent*

* database drill-up servlet
  * 'eventually consistent' --> trade-off to avoid global locking

* no top-level 'parallel' measurement

* Correlation ID etc.: as a 'context' of a measurement hierarchy (if present)
  * ASysMon.spawnNewCorrelation(...), ASysMon.joinCorrelation(...)
  * any time during a measurement --> knowledge of a correlation ID can come e.g. after parsing of a message, i.e. after JDBC or I/O
  * separate 'kind' and 'correlation id' to keep multiple
